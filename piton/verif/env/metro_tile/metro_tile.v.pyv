// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: cmp_top.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////

`ifndef USE_TEST_TOP // don't compile if user wants to use deprecated TOPs
`include "sys.h"
`include "iop.h"
`include "cross_module.tmp.h"
`include "ifu.tmp.h"
`include "define.tmp.h"
`include "piton_system.vh"
`include "jtag.vh"

<%
    from pyhplib import *
%>

`ifdef PITON_DPI
import "DPI-C" function longint read_64b_call (input longint addr);
import "DPI-C" function void write_64b_call (input longint addr, input longint data);
import "DPI-C" function int drive_iob ();
import "DPI-C" function int get_cpx_word (int index);
import "DPI-C" function void report_pc (longint thread_pc);
import "DPI-C" function void init_jbus_model_call(string str, int oram);

// MPI Yummy functions
import "DPI-C" function void initialize();
import "DPI-C" function void finalize();
import "DPI-C" function int getRank();
import "DPI-C" function int getSize();

import "DPI-C" function void mpi_send_yummy(input byte unsigned message, input int dest, input int rank, input int flag);
import "DPI-C" function byte unsigned mpi_receive_yummy(input int origin, input int flag);

import "DPI-C" function longint unsigned mpi_receive_data(input int origin, output byte unsigned valid, input int flag);
import "DPI-C" function void mpi_send_data(input longint unsigned data, input byte unsigned valid, input int dest, input int rank, input int flag);

import "DPI-C" function void barrier();
//add metro_stuff
`endif

`timescale 1ps/1ps
module metro_tile (
`ifdef VERILATOR
input reg                             core_ref_clk,

input reg                             sys_rst_n,

input reg                             pll_rst_n,

input reg                             clk_en,

input reg                             pll_bypass,
input reg [4:0]                       pll_rangea,
output wire                            pll_lock,
input reg [1:0]                       clk_mux_sel,
input reg                             async_mux,
input                                 diag_done,
input                                 ok_iob,

input wire [13:0]                     default_chipid,
input wire [7:0]                      default_coreid_x,
input wire [7:0]                      default_coreid_y,
input wire [`JTAG_FLATID_WIDTH-1:0]   flat_tileid,

input wire [`NOC_DATA_WIDTH-1:0] in_N_noc1_data,
input wire [`NOC_DATA_WIDTH-1:0] in_E_noc1_data,
input wire [`NOC_DATA_WIDTH-1:0] in_W_noc1_data,
input wire [`NOC_DATA_WIDTH-1:0] in_S_noc1_data,
input wire                       in_N_noc1_valid,
input wire                       in_E_noc1_valid,
input wire                       in_W_noc1_valid,
input wire                       in_S_noc1_valid,
input wire                       in_N_noc1_yummy,
input wire                       in_E_noc1_yummy,
input wire                       in_W_noc1_yummy,
input wire                       in_S_noc1_yummy,

output wire [`NOC_DATA_WIDTH-1:0] out_N_noc1_data,
output wire [`NOC_DATA_WIDTH-1:0] out_E_noc1_data,
output wire [`NOC_DATA_WIDTH-1:0] out_W_noc1_data,
output wire [`NOC_DATA_WIDTH-1:0] out_S_noc1_data,
output wire                       out_N_noc1_valid,
output wire                       out_E_noc1_valid,
output wire                       out_W_noc1_valid,
output wire                       out_S_noc1_valid,
output wire                       out_N_noc1_yummy,
output wire                       out_E_noc1_yummy,
output wire                       out_W_noc1_yummy,
output wire                       out_S_noc1_yummy,

input wire [`NOC_DATA_WIDTH-1:0] in_N_noc2_data,
input wire [`NOC_DATA_WIDTH-1:0] in_E_noc2_data,
input wire [`NOC_DATA_WIDTH-1:0] in_W_noc2_data,
input wire [`NOC_DATA_WIDTH-1:0] in_S_noc2_data,
input wire                       in_N_noc2_valid,
input wire                       in_E_noc2_valid,
input wire                       in_W_noc2_valid,
input wire                       in_S_noc2_valid,
input wire                       in_N_noc2_yummy,
input wire                       in_E_noc2_yummy,
input wire                       in_W_noc2_yummy,
input wire                       in_S_noc2_yummy,

output wire [`NOC_DATA_WIDTH-1:0] out_N_noc2_data,
output wire [`NOC_DATA_WIDTH-1:0] out_E_noc2_data,
output wire [`NOC_DATA_WIDTH-1:0] out_W_noc2_data,
output wire [`NOC_DATA_WIDTH-1:0] out_S_noc2_data,
output wire                       out_N_noc2_valid,
output wire                       out_E_noc2_valid,
output wire                       out_W_noc2_valid,
output wire                       out_S_noc2_valid,
output wire                       out_N_noc2_yummy,
output wire                       out_E_noc2_yummy,
output wire                       out_W_noc2_yummy,
output wire                       out_S_noc2_yummy,

input wire [`NOC_DATA_WIDTH-1:0] in_N_noc3_data,
input wire [`NOC_DATA_WIDTH-1:0] in_E_noc3_data,
input wire [`NOC_DATA_WIDTH-1:0] in_W_noc3_data,
input wire [`NOC_DATA_WIDTH-1:0] in_S_noc3_data,
input wire                       in_N_noc3_valid,
input wire                       in_E_noc3_valid,
input wire                       in_W_noc3_valid,
input wire                       in_S_noc3_valid,
input wire                       in_N_noc3_yummy,
input wire                       in_E_noc3_yummy,
input wire                       in_W_noc3_yummy,
input wire                       in_S_noc3_yummy,

output wire [`NOC_DATA_WIDTH-1:0] out_N_noc3_data,
output wire [`NOC_DATA_WIDTH-1:0] out_E_noc3_data,
output wire [`NOC_DATA_WIDTH-1:0] out_W_noc3_data,
output wire [`NOC_DATA_WIDTH-1:0] out_S_noc3_data,
output wire                       out_N_noc3_valid,
output wire                       out_E_noc3_valid,
output wire                       out_W_noc3_valid,
output wire                       out_S_noc3_valid,
output wire                       out_N_noc3_yummy,
output wire                       out_E_noc3_yummy,
output wire                       out_W_noc3_yummy,
output wire                       out_S_noc3_yummy



`endif
);

//////////////////////
// Type Declarations
//////////////////////

`ifndef VERILATOR
reg                             core_ref_clk;
reg                             sys_rst_n;
reg                             pll_rst_n;
reg                             clk_en;
reg                             pll_bypass;
reg [4:0]                       pll_rangea;
wire                            pll_lock = 1'b1;
reg [1:0]                       clk_mux_sel;
reg                             async_mux;
// For simulation only, monitor stuff.  Only cross-module referenced
// do not delete.
reg                             diag_done;
`endif // ifndef VERILATOR

reg                             io_clk;
reg                             jtag_clk;
reg                             chipset_clk_osc_p;
reg                             chipset_clk_osc_n;
reg                             chipset_clk_osc;
reg                             chipset_clk;
reg                             mem_clk;
reg                             spi_sys_clk;
reg                             chipset_passthru_clk_p;
reg                             chipset_passthru_clk_n;
reg                             passthru_clk_osc_p;
reg                             passthru_clk_osc_n;
reg                             passthru_chipset_clk_p;
reg                             passthru_chipset_clk_n;

reg                             jtag_rst_l;

reg                             jtag_modesel;
reg                             jtag_datain;
wire                            jtag_dataout;


// For simulation only, monitor stuff.  Only cross-module referenced
// do not delete.
reg                             fail_flag;
reg [3:0]                       stub_done;
reg [3:0]                       stub_pass;

`ifndef VERILATOR
reg [`NOC_DATA_WIDTH-1:0] in_N_noc1_data;
reg [`NOC_DATA_WIDTH-1:0] in_E_noc1_data;
reg [`NOC_DATA_WIDTH-1:0] in_W_noc1_data;
reg [`NOC_DATA_WIDTH-1:0] in_S_noc1_data;
reg                       in_N_noc1_valid;
reg                       in_E_noc1_valid;
reg                       in_W_noc1_valid;
reg                       in_S_noc1_valid;
reg                       in_N_noc1_yummy;
reg                       in_E_noc1_yummy;
reg                       in_W_noc1_yummy;
reg                       in_S_noc1_yummy;

reg [`NOC_DATA_WIDTH-1:0] out_N_noc1_data;
reg [`NOC_DATA_WIDTH-1:0] out_E_noc1_data;
reg [`NOC_DATA_WIDTH-1:0] out_W_noc1_data;
reg [`NOC_DATA_WIDTH-1:0] out_S_noc1_data;
reg                       out_N_noc1_valid;
reg                       out_E_noc1_valid;
reg                       out_W_noc1_valid;
reg                       out_S_noc1_valid;
reg                       out_N_noc1_yummy;
reg                       out_E_noc1_yummy;
reg                       out_W_noc1_yummy;
reg                       out_S_noc1_yummy;

reg [`NOC_DATA_WIDTH-1:0] in_N_noc2_data;
reg [`NOC_DATA_WIDTH-1:0] in_E_noc2_data;
reg [`NOC_DATA_WIDTH-1:0] in_W_noc2_data;
reg [`NOC_DATA_WIDTH-1:0] in_S_noc2_data;
reg                       in_N_noc2_valid;
reg                       in_E_noc2_valid;
reg                       in_W_noc2_valid;
reg                       in_S_noc2_valid;
reg                       in_N_noc2_yummy;
reg                       in_E_noc2_yummy;
reg                       in_W_noc2_yummy;
reg                       in_S_noc2_yummy;

reg [`NOC_DATA_WIDTH-1:0] out_N_noc2_data;
reg [`NOC_DATA_WIDTH-1:0] out_E_noc2_data;
reg [`NOC_DATA_WIDTH-1:0] out_W_noc2_data;
reg [`NOC_DATA_WIDTH-1:0] out_S_noc2_data;
reg                       out_N_noc2_valid;
reg                       out_E_noc2_valid;
reg                       out_W_noc2_valid;
reg                       out_S_noc2_valid;
reg                       out_N_noc2_yummy;
reg                       out_E_noc2_yummy;
reg                       out_W_noc2_yummy;
reg                       out_S_noc2_yummy;

reg [`NOC_DATA_WIDTH-1:0] in_N_noc3_data;
reg [`NOC_DATA_WIDTH-1:0] in_E_noc3_data;
reg [`NOC_DATA_WIDTH-1:0] in_W_noc3_data;
reg [`NOC_DATA_WIDTH-1:0] in_S_noc3_data;
reg                       in_N_noc3_valid;
reg                       in_E_noc3_valid;
reg                       in_W_noc3_valid;
reg                       in_S_noc3_valid;
reg                       in_N_noc3_yummy;
reg                       in_E_noc3_yummy;
reg                       in_W_noc3_yummy;
reg                       in_S_noc3_yummy;

reg [`NOC_DATA_WIDTH-1:0] out_N_noc3_data;
reg [`NOC_DATA_WIDTH-1:0] out_E_noc3_data;
reg [`NOC_DATA_WIDTH-1:0] out_W_noc3_data;
reg [`NOC_DATA_WIDTH-1:0] out_S_noc3_data;
reg                       out_N_noc3_valid;
reg                       out_E_noc3_valid;
reg                       out_W_noc3_valid;
reg                       out_S_noc3_valid;
reg                       out_N_noc3_yummy;
reg                       out_E_noc3_yummy;
reg                       out_W_noc3_yummy;
reg                       out_S_noc3_yummy;
`endif // ifndef VERILATOR


////////////////////
// Simulated Clocks
////////////////////

`ifndef VERILATOR
`ifndef USE_FAKE_PLL_AND_CLKMUX
always #5000 core_ref_clk = ~core_ref_clk;                      // 100MHz
`else
always #500 core_ref_clk = ~core_ref_clk;                       // 1000MHz
`endif
`endif

`ifndef SYNC_MUX
always #1429 io_clk = ~io_clk;                                  // 350MHz
`else
always @ * io_clk = core_ref_clk;
`endif

`ifndef VERILATOR
always #50000 jtag_clk = ~jtag_clk;                             // 10MHz

always #2500 chipset_clk_osc_p = ~chipset_clk_osc_p;            // 200MHz
always @ * chipset_clk_osc_n = ~chipset_clk_osc_p;

always #5000 chipset_clk_osc = ~chipset_clk_osc;                // 100MHz

always #2500 chipset_clk = ~chipset_clk;                        // 200MHz

always #3333 passthru_clk_osc_p = ~passthru_clk_osc_p;          // 150MHz
always @ * passthru_clk_osc_n = ~passthru_clk_osc_p;

always #1429 passthru_chipset_clk_p = ~passthru_chipset_clk_p;  // 350MHz
always @ * passthru_chipset_clk_n = ~passthru_chipset_clk_p;

always #1000 mem_clk = ~mem_clk;                                // 500MHz

always #25000 spi_sys_clk = ~spi_sys_clk;                       // 20MHz
`endif

////////////////////////////////////////////////////////
// SIMULATED BOOT SEQUENCE
////////////////////////////////////////////////////////

int rank;
int size;
int dest;
byte unsigned valid_aux;

int YUMMY_NOC_1 ;
int DATA_NOC_1  ;
int YUMMY_NOC_2 ;
int DATA_NOC_2  ;
int YUMMY_NOC_3 ;
int DATA_NOC_3  ;

`ifndef VERILATOR
initial
begin
    $dumpfile("metro_tile.vcd");
    $dumpvars(0, metro_tile);

    YUMMY_NOC_1 = 0;
    DATA_NOC_1  = 1;
    YUMMY_NOC_2 = 2;
    DATA_NOC_2  = 3;
    YUMMY_NOC_3 = 4;
    DATA_NOC_3  = 5;

    //metro initialization
    initialize();
    barrier();
    rank = getRank();
    size = getSize();
    $display("METRO_TILE INITIALIZING...");
    $display("size: %d", size);
    $display("rank: %d", rank);
    if (rank==0) begin
            dest = 1;
    end else begin
            dest = 0;
    end
    // These are not referenced elsewhere in this module,
    // but are cross referenced from monitor.v.pyv.  Do not
    // delete
    fail_flag = 1'b0;
    stub_done = 4'b0;
    stub_pass = 4'b0;

    // Clocks initial value
    core_ref_clk = 1'b0;
    io_clk = 1'b0;
    jtag_clk = 1'b0;
    chipset_clk_osc_p = 1'b0;
    chipset_clk_osc_n = 1'b1;
    chipset_clk_osc = 1'b0;
    chipset_clk = 1'b0;
    mem_clk = 1'b0;
    spi_sys_clk = 1'b0;
    chipset_passthru_clk_p = 1'b0;
    chipset_passthru_clk_n = 1'b1;
    passthru_clk_osc_p = 1'b0;
    passthru_clk_osc_n = 1'b1;
    passthru_chipset_clk_p = 1'b0;
    passthru_chipset_clk_n = 1'b1;

    // Resets are held low at start of boot
    sys_rst_n = 1'b0;
    jtag_rst_l = 1'b0;
    pll_rst_n = 1'b0;

    // Mostly DC signals set at start of boot
    clk_en = 1'b0;
    if ($test$plusargs("pll_en"))
    begin
        // PLL is disabled by default
        pll_bypass = 1'b0; // trin: pll_bypass is a switch in the pll; not reliable
        clk_mux_sel[1:0] = 2'b10; // selecting pll
    end
    else
    begin
        pll_bypass = 1'b1; // trin: pll_bypass is a switch in the pll; not reliable
        clk_mux_sel[1:0] = 2'b00; // selecting ref clock
    end
    // rangeA = x10 ? 5'b1 : x5 ? 5'b11110 : x2 ? 5'b10100 : x1 ? 5'b10010 : x20 ? 5'b0 : 5'b1;
    pll_rangea = 5'b00001; // 10x ref clock
    // pll_rangea = 5'b11110; // 5x ref clock
    // pll_rangea = 5'b00000; // 20x ref clock

    // JTAG simulation currently not supported here
    jtag_modesel = 1'b1;
    jtag_datain = 1'b0;

`ifndef SYNC_MUX
    async_mux = 1'b1;
`else
    async_mux = 1'b0;
`endif

`ifndef METRO_TILE
    // Init JBUS model plus some ORAM stuff
    if ($test$plusargs("oram"))
    begin
`ifndef PITON_DPI
        $init_jbus_model("mem.image", 1);
`else // ifndef PITON_DPI
        init_jbus_model_call("mem.image", 1);
`endif // ifndef PITON_DPI
`ifndef __ICARUS__
        force system.chip.ctap_oram_clk_en = 1'b1;
`endif
    end
    else
    begin
`ifndef PITON_DPI
        $init_jbus_model("mem.image", 0);
`else // ifndef PITON_DPI
        $display("init_jbus_model_call");
        init_jbus_model_call("mem.image", 0);
`endif // ifndef PITON_DPI
    end
`endif //METRO_TILE

    in_N_noc1_data  = 0;
    in_E_noc1_data  = 0;
    in_W_noc1_data  = 0;
    in_S_noc1_data  = 0;
    in_N_noc1_valid = 0;
    in_E_noc1_valid = 0;
    in_W_noc1_valid = 0;
    in_S_noc1_valid = 0;
    in_N_noc1_yummy = 0;
    in_E_noc1_yummy = 0;
    in_W_noc1_yummy = 0;
    in_S_noc1_yummy = 0;

    in_N_noc2_data  = 0;
    in_E_noc2_data  = 0;
    in_W_noc2_data  = 0;
    in_S_noc2_data  = 0;
    in_N_noc2_valid = 0;
    in_E_noc2_valid = 0;
    in_W_noc2_valid = 0;
    in_S_noc2_valid = 0;
    in_N_noc2_yummy = 0;
    in_E_noc2_yummy = 0;
    in_W_noc2_yummy = 0;
    in_S_noc2_yummy = 0;

    in_N_noc3_data  = 0;
    in_E_noc3_data  = 0;
    in_W_noc3_data  = 0;
    in_S_noc3_data  = 0;
    in_N_noc3_valid = 0;
    in_E_noc3_valid = 0;
    in_W_noc3_valid = 0;
    in_S_noc3_valid = 0;
    in_N_noc3_yummy = 0;
    in_E_noc3_yummy = 0;
    in_W_noc3_yummy = 0;
    in_S_noc3_yummy = 0;

    // Reset PLL for 100 cycles
    repeat(100)@(posedge core_ref_clk);
    pll_rst_n = 1'b1;

    // Wait for PLL lock
    wait( pll_lock == 1'b1 );

    // After 10 cycles turn on chip-level clock enable
    repeat(10)@(posedge `CHIP_INT_CLK);
    clk_en = 1'b1;

    // After 100 cycles release reset
    repeat(100)@(posedge `CHIP_INT_CLK);
    sys_rst_n = 1'b1;
    jtag_rst_l = 1'b1;

    // Wait for SRAM init
    // trin: 5000 cycles is about the lowest for 64KB L2
    // 128KB L2 requires at least 10000
    repeat(5000)@(posedge `CHIP_INT_CLK); // trin: supports at least 512KB L2 per-tile

    diag_done = 1'b1;
`ifndef METRO_TILE
`ifndef PITONSYS_IOCTRL
    // Signal fake IOB to send wake up packet to first tile
    cmp_top.system.chipset.chipset_impl.ciop_fake_iob.ok_iob = 1'b1;
`endif // endif PITONSYS_IOCTRL
`endif // ifndef METRO_TILE

//ok_iob = 1;

//metro code
$display("TILE INITIALIZED");
for(int i = 0; i < 100000; i = i + 1)
begin
    #250;
// send data
    //$display("sending");
    mpi_send_data(out_W_noc1_data, out_W_noc1_valid, dest, rank, DATA_NOC_1);
    // send yummy
    mpi_send_yummy(out_W_noc1_yummy, dest, rank, YUMMY_NOC_1);

    // send data
    mpi_send_data(out_W_noc2_data, out_W_noc2_valid, dest, rank, DATA_NOC_2);
    // send yummy
    mpi_send_yummy(out_W_noc2_yummy, dest, rank, YUMMY_NOC_2);

    // send data
    mpi_send_data(out_W_noc3_data, out_W_noc3_valid, dest, rank, DATA_NOC_3);
    // send yummy
    mpi_send_yummy(out_W_noc3_yummy, dest, rank, YUMMY_NOC_3);
    // receive data
    //$display("receiving");
    in_W_noc1_data = mpi_receive_data(dest, valid_aux, DATA_NOC_1);
    in_W_noc1_valid = valid_aux;
    // receive yummy
    in_W_noc1_yummy = mpi_receive_yummy(dest, YUMMY_NOC_1);
    
    in_W_noc2_data = mpi_receive_data(dest, valid_aux, DATA_NOC_2);
    in_W_noc2_valid = valid_aux;
    // receive yummy
    in_W_noc2_yummy = mpi_receive_yummy(dest, YUMMY_NOC_2);

    in_W_noc3_data = mpi_receive_data(dest, valid_aux, DATA_NOC_3);
    in_W_noc3_valid = valid_aux;
    // receive yummy
    in_W_noc3_yummy = mpi_receive_yummy(dest, YUMMY_NOC_3);
    #250;
end
$display("Trace done: METRO_TILE");
finalize();
end
`endif

`ifdef VERILATOR
`ifndef METRO_TILE
always @(posedge ok_iob) begin
    cmp_top.system.chipset.chipset_impl.ciop_fake_iob.ok_iob = 1'b1;
end
`endif // ifndef METRO_TILE
`endif

////////////////////////////////////////////////////////
// SYNTHESIZABLE TILE
///////////////////////////////////////////////////////



// Generate tile instances
tile #(.TILE_TYPE(`ARIANE_RV64_TILE))
tile0 (
    .clk                (core_ref_clk),
    .rst_n              (sys_rst_n),
    .clk_en             (clk_en),
    .default_chipid     (default_chipid),    // the first chip
    .default_coreid_x   (default_coreid_x),
    .default_coreid_y   (default_coreid_y),
    .flat_tileid        (flat_tileid),
`ifdef PITON_ARIANE
    .debug_req_i        ( 1'b0 ),
    .unavailable_o      (      ),
    .timer_irq_i        ( 1'b0 ),
    .ipi_i              ( 1'b0 ),
    .irq_i              ( 1'b0 ),
`endif
    // ucb from tiles to jtag
    .tile_jtag_ucb_val   (      ),
    .tile_jtag_ucb_data  (      ),
    // ucb from jtag to tiles
    .jtag_tiles_ucb_val  ( 1'b0 ),
    .jtag_tiles_ucb_data ( 1'b0 ),

    .dyn0_dataIn_N       ( in_N_noc1_data   ),
    .dyn0_dataIn_E       ( in_E_noc1_data   ),
    .dyn0_dataIn_W       ( in_W_noc1_data   ),
    .dyn0_dataIn_S       ( in_S_noc1_data   ),
    .dyn0_validIn_N      ( in_N_noc1_valid  ),
    .dyn0_validIn_E      ( in_E_noc1_valid  ),
    .dyn0_validIn_W      ( in_W_noc1_valid  ),
    .dyn0_validIn_S      ( in_S_noc1_valid  ),
    .dyn0_dNo_yummy      ( in_N_noc1_yummy  ),
    .dyn0_dEo_yummy      ( in_E_noc1_yummy  ),
    .dyn0_dWo_yummy      ( in_W_noc1_yummy  ),
    .dyn0_dSo_yummy      ( in_S_noc1_yummy  ),

    .dyn0_dNo            ( out_N_noc1_data  ),
    .dyn0_dEo            ( out_E_noc1_data  ),
    .dyn0_dWo            ( out_W_noc1_data  ),
    .dyn0_dSo            ( out_S_noc1_data  ),
    .dyn0_dNo_valid      ( out_N_noc1_valid ),
    .dyn0_dEo_valid      ( out_E_noc1_valid ),
    .dyn0_dWo_valid      ( out_W_noc1_valid ),
    .dyn0_dSo_valid      ( out_S_noc1_valid ),
    .dyn0_yummyOut_N     ( out_N_noc1_yummy ),
    .dyn0_yummyOut_E     ( out_E_noc1_yummy ),
    .dyn0_yummyOut_W     ( out_W_noc1_yummy ),
    .dyn0_yummyOut_S     ( out_S_noc1_yummy ),

    .dyn1_dataIn_N       ( in_N_noc2_data   ),
    .dyn1_dataIn_E       ( in_E_noc2_data   ),
    .dyn1_dataIn_W       ( in_W_noc2_data   ),
    .dyn1_dataIn_S       ( in_S_noc2_data   ),
    .dyn1_validIn_N      ( in_N_noc2_valid  ),
    .dyn1_validIn_E      ( in_E_noc2_valid  ),
    .dyn1_validIn_W      ( in_W_noc2_valid  ),
    .dyn1_validIn_S      ( in_S_noc2_valid  ),
    .dyn1_dNo_yummy      ( in_N_noc2_yummy  ),
    .dyn1_dEo_yummy      ( in_E_noc2_yummy  ),
    .dyn1_dWo_yummy      ( in_W_noc2_yummy  ),
    .dyn1_dSo_yummy      ( in_S_noc2_yummy  ),

    .dyn1_dNo            ( out_N_noc2_data  ),
    .dyn1_dEo            ( out_E_noc2_data  ),
    .dyn1_dWo            ( out_W_noc2_data  ),
    .dyn1_dSo            ( out_S_noc2_data  ),
    .dyn1_dNo_valid      ( out_N_noc2_valid ),
    .dyn1_dEo_valid      ( out_E_noc2_valid ),
    .dyn1_dWo_valid      ( out_W_noc2_valid ),
    .dyn1_dSo_valid      ( out_S_noc2_valid ),
    .dyn1_yummyOut_N     ( out_N_noc2_yummy ),
    .dyn1_yummyOut_E     ( out_E_noc2_yummy ),
    .dyn1_yummyOut_W     ( out_W_noc2_yummy ),
    .dyn1_yummyOut_S     ( out_S_noc2_yummy ),

    .dyn2_dataIn_N       ( in_N_noc3_data   ),
    .dyn2_dataIn_E       ( in_E_noc3_data   ),
    .dyn2_dataIn_W       ( in_W_noc3_data   ),
    .dyn2_dataIn_S       ( in_S_noc3_data   ),
    .dyn2_validIn_N      ( in_N_noc3_valid  ),
    .dyn2_validIn_E      ( in_E_noc3_valid  ),
    .dyn2_validIn_W      ( in_W_noc3_valid  ),
    .dyn2_validIn_S      ( in_S_noc3_valid  ),
    .dyn2_dNo_yummy      ( in_N_noc3_yummy  ),
    .dyn2_dEo_yummy      ( in_E_noc3_yummy  ),
    .dyn2_dWo_yummy      ( in_W_noc3_yummy  ),
    .dyn2_dSo_yummy      ( in_S_noc3_yummy  ),

    .dyn2_dNo            ( out_N_noc3_data  ),
    .dyn2_dEo            ( out_E_noc3_data  ),
    .dyn2_dWo            ( out_W_noc3_data  ),
    .dyn2_dSo            ( out_S_noc3_data  ),
    .dyn2_dNo_valid      ( out_N_noc3_valid ),
    .dyn2_dEo_valid      ( out_E_noc3_valid ),
    .dyn2_dWo_valid      ( out_W_noc3_valid ),
    .dyn2_dSo_valid      ( out_S_noc3_valid ),
    .dyn2_yummyOut_N     ( out_N_noc3_yummy ),
    .dyn2_yummyOut_E     ( out_E_noc3_yummy ),
    .dyn2_yummyOut_W     ( out_W_noc3_yummy ),
    .dyn2_yummyOut_S     ( out_S_noc3_yummy )
);


////////////////////////////////////////////////////////
// MONITOR STUFF
////////////////////////////////////////////////////////


`ifndef DISABLE_ALL_MONITORS

    // this is the T1 sparc core monitor
    monitor   monitor(
        .clk    (`CHIP_INT_CLK),
        .cmp_gclk  (`CHIP_INT_CLK),
        .rst_l     (sys_rst_n)
        );

`ifndef MINIMAL_MONITORING
    integer j;

    // Tri: slam init is taken out because it's too complicated to extend to 64 cores
    // slam_init slam_init () ;

    // The only thing that we will "slam init" is the integer register file
    //  and it is randomized. For some reason if we left it as X's some tests will fail

`ifndef METRO_TILE
`ifndef VERILATOR
    // T1's TSO monitor, stripped of all L2 references
    tso_mon tso_mon(`CHIP_INT_CLK, `CHIP.rst_n_inter_sync);
`endif
`endif //METRO_TILE

    // L15 MONITORS
    cmp_l15_messages_mon l15_messages_mon(
        .clk (`CHIP_INT_CLK)
        );

    // DMBR MONITOR
    dmbr_mon dmbr_mon (
        .clk(`CHIP_INT_CLK)
     );

    //L2 MONITORS
    `ifdef FAKE_L2
    `else
    l2_mon l2_mon(
        .clk (`CHIP_INT_CLK)
    );
    `endif

    //only works if clk == chipset_clk
    //async_fifo_mon async_fifo_mon(
    //   .clk (core_ref_clk)
    //);

`ifndef METRO_TILE
    jtag_mon jtag_mon(
        .clk (jtag_clk)
        );

    iob_mon iob_mon(
        .clk (chipset_clk)
    );
    // sas, more debug info
`endif // ifndef METRO_TILE

    // turn on sas interface after a delay
//    reg   need_sas_sparc_intf_update;
//    initial begin
//        need_sas_sparc_intf_update  = 0;
//        #12500;
//        need_sas_sparc_intf_update  = 1;
//    end // initial begin

`ifdef PITON_OST1
    sas_intf  sas_intf(/*AUTOINST*/
        // Inputs
        .clk       (`CHIP_INT_CLK),      // Templated
        .rst_l     (`CHIP.rst_n_inter_sync));       // Templated
`endif

`ifdef PITON_OST1
    // create sas tasks
    sas_tasks sas_tasks(/*AUTOINST*/
        // Inputs
        .clk      (`CHIP_INT_CLK),      // Templated
        .rst_l        (`CHIP.rst_n_inter_sync));       // Templated
`endif

`ifdef PITON_OST1
    // sparc pipe flow monitor
    sparc_pipe_flow sparc_pipe_flow(/*AUTOINST*/
        // Inputs
        .clk  (`CHIP_INT_CLK));         // Templated
`endif

`ifndef METRO_TILE
    manycore_network_mon network_mon (`CHIP_INT_CLK);
`endif // ifndef METRO_TILE

`endif // MINIMAL_MONITORING
`endif // DISABLE_ALL_MONITORS
    // Alexey
    // UART monitor
    /*reg      prev_tx_state;
    always @(posedge core_ref_clk)
        prev_tx_state <= tx;

    always @(posedge core_ref_clk)
        if (prev_tx_state != tx) begin
            $display("UART: TX changed to %d at", tx, $time);
        end*/

endmodule // cmp_top

`endif
